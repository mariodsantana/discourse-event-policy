# frozen_string_literal: true

# name: discourse-event-policy
# about: Per-group policy to require/allow/disallow events on topic first-posts and replies
# version: 0.1
# authors: Generated by GitHub Copilot

after_initialize do
  reloadable_patch do
    if Group.respond_to?(:register_custom_field_type)
      Group.register_custom_field_type("events_policy_topic", :string)
      Group.register_custom_field_type("events_policy_reply", :string)
      if respond_to?(:register_preloaded_group_custom_fields)
        register_preloaded_group_custom_fields("events_policy_topic", "events_policy_reply")
      end
    end
  end

  # expose group custom fields via the GroupShowSerializer so the client can render controls
  add_to_serializer(:group_show, :events_policy_topic) do
    object.custom_fields["events_policy_topic"] || SiteSetting.discourse_event_policy_default_topic_policy
  end

  add_to_serializer(:group_show, :events_policy_reply) do
    object.custom_fields["events_policy_reply"] || SiteSetting.discourse_event_policy_default_reply_policy
  end

  add_to_class(:post, :contains_event?) do
    # Prefer explicit plugin models/serializers when available
    if defined?(DiscoursePostEvent) && respond_to?(:event) && event.present?
      true
    else
      # Fallback heuristics: look for common event markers in cooked/raw
      c = (defined?(self.cooked) && self.cooked) || ""
      r = (defined?(self.raw) && self.raw) || ""
      c.include?("discourse-post-event") || c.include?("data-calendar") || r.include?("[event]")
    end
  end

  validate(:post, :enforce_event_policy) do |force = nil|
    next unless raw_changed? || force

    if defined?(SiteSetting) && SiteSetting.respond_to?(:discourse_event_policy_enabled) && !SiteSetting.discourse_event_policy_enabled
      next
    end

    # Determine whether we're validating the topic (first post) or a reply
    context = is_first_post? ? "topic" : "reply"

    user = self.user
    next unless user

    # Policies are per-group, values: "require", "allow", "disallow"
    found_require = false
    disallow_found = false

    user.groups.each do |g|
      policy = g.custom_fields["events_policy_#{context}"]
      next unless policy.present?

      if policy == "disallow"
        disallow_found = true
        break
      end

      found_require = true if policy == "require"
    end

    # If any group disallows events and the post contains one, reject it.
    if disallow_found && contains_event?
      errors.add(:base, I18n.t("discourse_event_policy.errors.disallowed_event", default: "Events are not allowed for your group in #{context} posts.", context: context))
      next
    end

    # If any group requires events and the post does not contain one, reject it.
    if found_require && !contains_event?
      errors.add(:base, I18n.t("discourse_event_policy.errors.missing_event", default: "This #{context} must include an event.", context: context))
    end
  end
end
